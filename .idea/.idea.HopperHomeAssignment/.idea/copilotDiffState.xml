<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/HopperHomeAssignment/Config.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HopperHomeAssignment/Config.cs" />
              <option name="originalContent" value="using System.Text.Json;&#10;using Serilog;&#10;&#10;namespace HopperHomeAssignment;&#10;&#10;public sealed class Config&#10;{&#10;    public required List&lt;string&gt; Urls { get; init; }&#10;    public required TimeSpan MaxDownloadTime { get; init; }&#10;    public required string OutputPath { get; init; }&#10;    public required int MaxConcurrentDownloads { get; init; }&#10;&#10;    private static readonly JsonSerializerOptions JsonOptions = new()&#10;    {&#10;        PropertyNameCaseInsensitive = true,&#10;    };&#10;&#10;    // Factory as a constructor alternative, to allow async file reading&#10;    public static async Task&lt;Config&gt; LoadFromFileAsync(FileInfo filePath, CancellationToken cancellationToken = default)&#10;    {&#10;        if (!filePath.Exists)&#10;        {&#10;            throw new FileNotFoundException(Messages.ConfigFileNotFound.Replace(&quot;{Path}&quot;, filePath.FullName));&#10;        }&#10;&#10;        await using var stream = filePath.OpenRead();&#10;        var config = await JsonSerializer.DeserializeAsync&lt;Config&gt;(stream, JsonOptions, cancellationToken) ??&#10;                     throw new InvalidDataException(Messages.ConfigDeserializeFailed);&#10;&#10;        config.Validate();&#10;        return config;&#10;    }&#10;&#10;    public void Validate()&#10;    {&#10;        if (Urls.Count == 0)&#10;        {&#10;            throw new InvalidDataException(Messages.UrlListEmpty);&#10;        }&#10;&#10;        if (string.IsNullOrWhiteSpace(OutputPath))&#10;        {&#10;            throw new InvalidDataException(Messages.OutputPathEmpty);&#10;        }&#10;&#10;        if (MaxConcurrentDownloads &lt;= 0)&#10;        {&#10;            throw new InvalidDataException(Messages.MaxConcurrentDownloadsInvalid);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Text.Json;&#10;using Serilog;&#10;&#10;namespace HopperHomeAssignment;&#10;&#10;public sealed class Config&#10;{&#10;    public required List&lt;string&gt; Urls { get; init; }&#10;    public required TimeSpan MaxDownloadTime { get; init; }&#10;    public required string OutputPath { get; init; }&#10;    public required int MaxConcurrentDownloads { get; init; }&#10;&#10;    private static readonly JsonSerializerOptions JsonOptions = new()&#10;    {&#10;        PropertyNameCaseInsensitive = true,&#10;    };&#10;&#10;    // Factory method instead of constructor to enable async file I/O&#10;    // This pattern allows us to perform async operations during object creation&#10;    public static async Task&lt;Config&gt; LoadFromFileAsync(FileInfo filePath, CancellationToken cancellationToken = default)&#10;    {&#10;        if (!filePath.Exists)&#10;        {&#10;            throw new FileNotFoundException(Messages.ConfigFileNotFound.Replace(&quot;{Path}&quot;, filePath.FullName));&#10;        }&#10;&#10;        await using var stream = filePath.OpenRead();&#10;        var config = await JsonSerializer.DeserializeAsync&lt;Config&gt;(stream, JsonOptions, cancellationToken) ??&#10;                     throw new InvalidDataException(Messages.ConfigDeserializeFailed);&#10;&#10;        // Validate configuration immediately after loading&#10;        config.Validate();&#10;        return config;&#10;    }&#10;&#10;    public void Validate()&#10;    {&#10;        // Ensure we have at least one URL to download&#10;        if (Urls.Count == 0)&#10;        {&#10;            throw new InvalidDataException(Messages.UrlListEmpty);&#10;        }&#10;&#10;        if (string.IsNullOrWhiteSpace(OutputPath))&#10;        {&#10;            throw new InvalidDataException(Messages.OutputPathEmpty);&#10;        }&#10;&#10;        // Concurrency level must be positive for semaphore to work&#10;        if (MaxConcurrentDownloads &lt;= 0)&#10;        {&#10;            throw new InvalidDataException(Messages.MaxConcurrentDownloadsInvalid);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HopperHomeAssignment/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HopperHomeAssignment/Program.cs" />
              <option name="originalContent" value="using System.CommandLine;&#10;using System.Runtime.Loader;&#10;using HopperHomeAssignment;&#10;using Serilog;&#10;&#10;Log.Logger = new LoggerConfiguration()&#10;    .MinimumLevel.Information()&#10;    .WriteTo.Console()&#10;    .CreateLogger();&#10;&#10;var cts = new CancellationTokenSource();&#10;ConsoleCancelEventHandler cancelHandler = (_, e) =&gt;&#10;{&#10;    e.Cancel = true;&#10;    Log.Warning(Messages.CancellationViaCtrlC);&#10;    cts.Cancel();&#10;};&#10;Console.CancelKeyPress += cancelHandler;&#10;&#10;Action&lt;object?&gt; unloadHandler = _ =&gt;&#10;{&#10;    Log.Warning(Messages.CancellationViaSigTerm);&#10;    cts.Cancel();&#10;};&#10;AssemblyLoadContext.Default.Unloading += unloadHandler;&#10;&#10;try&#10;{&#10;    var rootCommand = new RootCommand(&quot;Concurrent URL Downloader&quot;);&#10;&#10;    var configOption = new Option&lt;FileInfo&gt;(&quot;--config-path&quot;,&#10;        &quot;-file&quot;, &quot;-f&quot;, &quot;-path&quot;, &quot;-p&quot;, &quot;-config&quot;, &quot;-c&quot;)&#10;    {&#10;        Description = &quot;Path to the Json config file&quot;,&#10;        Required = true&#10;    };&#10;&#10;    configOption.AcceptExistingOnly();&#10;&#10;    rootCommand.Options.Add(configOption);&#10;&#10;    var parseResult = rootCommand.Parse(args);&#10;&#10;    if (parseResult.Errors.Count == 0 &amp;&amp; parseResult.GetValue(configOption) is FileInfo parsedFile)&#10;    {&#10;        try&#10;        {&#10;            var config = await Config.LoadFromFileAsync(parsedFile, cts.Token);&#10;            var downloader = new Downloader(config);&#10;            Log.Information(Messages.StartingDownloads, config.OutputPath, config.MaxConcurrentDownloads);&#10;            await downloader.StartAsync(cts.Token);&#10;            return 0;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            Log.Error(Messages.StartDownloadFailed, ex.Message);&#10;            return 1;&#10;        }&#10;    }&#10;&#10;    foreach (var parseError in parseResult.Errors)&#10;    {&#10;        Log.Error(Messages.ParseError, parseError.Message);&#10;    }&#10;&#10;    return 1;&#10;}&#10;catch (OperationCanceledException)&#10;{&#10;    Log.Warning(Messages.OperationCancelled);&#10;    return 2;&#10;}&#10;catch (Exception ex)&#10;{&#10;    Log.Error(Messages.UnhandledException, ex.GetType().Name, ex.Message);&#10;    return 1;&#10;}&#10;finally&#10;{&#10;    Console.CancelKeyPress -= cancelHandler;&#10;    AssemblyLoadContext.Default.Unloading -= unloadHandler;&#10;    Log.CloseAndFlush();&#10;}" />
              <option name="updatedContent" value="using System.CommandLine;&#10;using System.Runtime.Loader;&#10;using HopperHomeAssignment;&#10;using Serilog;&#10;&#10;Log.Logger = new LoggerConfiguration()&#10;    .MinimumLevel.Information()&#10;    .WriteTo.Console()&#10;    .CreateLogger();&#10;&#10;// Setup cancellation token source for graceful shutdown&#10;var cts = new CancellationTokenSource();&#10;&#10;// Handle Ctrl+C cancellation requests&#10;ConsoleCancelEventHandler cancelHandler = (_, e) =&gt;&#10;{&#10;    e.Cancel = true; // Prevent immediate process termination&#10;    Log.Warning(Messages.CancellationViaCtrlC);&#10;    cts.Cancel();&#10;};&#10;Console.CancelKeyPress += cancelHandler;&#10;&#10;// Handle SIGTERM cancellation requests (e.g., from process managers)&#10;Action&lt;object?&gt; unloadHandler = _ =&gt;&#10;{&#10;    Log.Warning(Messages.CancellationViaSigTerm);&#10;    cts.Cancel();&#10;};&#10;AssemblyLoadContext.Default.Unloading += unloadHandler;&#10;&#10;try&#10;{&#10;    var rootCommand = new RootCommand(&quot;Concurrent URL Downloader&quot;);&#10;&#10;    // Configure command-line option with multiple aliases for flexibility&#10;    var configOption = new Option&lt;FileInfo&gt;(&quot;--config-path&quot;,&#10;        &quot;-file&quot;, &quot;-f&quot;, &quot;-path&quot;, &quot;-p&quot;, &quot;-config&quot;, &quot;-c&quot;)&#10;    {&#10;        Description = &quot;Path to the Json config file&quot;,&#10;        Required = true&#10;    };&#10;&#10;    configOption.AcceptExistingOnly();&#10;&#10;    rootCommand.Options.Add(configOption);&#10;&#10;    var parseResult = rootCommand.Parse(args);&#10;&#10;    // Proceed only if parsing succeeded and we have a valid file&#10;    if (parseResult.Errors.Count == 0 &amp;&amp; parseResult.GetValue(configOption) is FileInfo parsedFile)&#10;    {&#10;        try&#10;        {&#10;            var config = await Config.LoadFromFileAsync(parsedFile, cts.Token);&#10;            var downloader = new Downloader(config);&#10;            Log.Information(Messages.StartingDownloads, config.OutputPath, config.MaxConcurrentDownloads);&#10;            await downloader.StartAsync(cts.Token);&#10;            return 0;&#10;        }&#10;        catch (Exception ex)&#10;        {&#10;            Log.Error(Messages.StartDownloadFailed, ex.Message);&#10;            return 1;&#10;        }&#10;    }&#10;&#10;    // Log all parsing errors if any occurred&#10;    foreach (var parseError in parseResult.Errors)&#10;    {&#10;        Log.Error(Messages.ParseError, parseError.Message);&#10;    }&#10;&#10;    return 1;&#10;}&#10;catch (OperationCanceledException)&#10;{&#10;    Log.Warning(Messages.OperationCancelled);&#10;    return 2; // Different exit code for cancellation&#10;}&#10;catch (Exception ex)&#10;{&#10;    Log.Error(Messages.UnhandledException, ex.GetType().Name, ex.Message);&#10;    return 1;&#10;}&#10;finally&#10;{&#10;    // Clean up event handlers to prevent memory leaks&#10;    Console.CancelKeyPress -= cancelHandler;&#10;    AssemblyLoadContext.Default.Unloading -= unloadHandler;&#10;    Log.CloseAndFlush();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>